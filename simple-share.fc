;;
;; Simple Share TON Smart contract
;;

;;
;;  ton-share-smc â€“ TON based smart contract for share allocation
;;
;;  Copyright (C) 2022 Alexander Gapak
;;
;;  This file is part of ton-share-smc.
;;
;;  ton-share-smc is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU General Public License as published by
;;  the Free Software Foundation, either version 3 of the License, or
;;  (at your option) any later version.
;;
;;  ton-share-smc is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU General Public License for more details.
;;
;;  You should have received a copy of the GNU General Public License
;;  along with ton-share-smc.  If not, see <https://www.gnu.org/licenses/>.
;;

slice txt::a_share() asm "<b 124 word A share| $, b> <s PUSHSLICE";
slice txt::b_share() asm "<b 124 word B share| $, b> <s PUSHSLICE";

_ unpack_storage() inline_ref {
    var ds = get_data().begin_parse();
    var unpacked = (
        ds~load_uint(7), ds~load_msg_addr(), 
        ds~load_uint(7), ds~load_msg_addr()
    );
    
    ds.end_parse();
    return unpacked;
}

() send_tons(slice addr, int amount, int mode, slice body) impure inline_ref {
    builder msg = begin_cell()
                    .store_uint(0x10, 6)
                    .store_slice(addr)
                    .store_grams(amount)
                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                    .store_uint(0, 32)  ;; op: 0
                    .store_slice(body);

    send_raw_message(msg.end_cell(), mode);
}

() recv_internal(int my_balance, int msg_value, cell msg, slice msg_body) impure {
    slice cs = msg.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {
        return ();  ;; ignore all bounced messages
    }

    (int a_share, slice a_addr, int b_share, slice b_addr) = unpack_storage();
    
    if ((my_balance - msg_value) < (1 << 29)) { 
        msg_value -= (1 << 29); 
    }
    
    throw_if(0, msg_value < 0);

    send_tons(a_addr, msg_value / 100 * a_share, 3, txt::a_share());
    send_tons(b_addr, msg_value / 100 * b_share, 3, txt::b_share());
}


(int, slice, int, slice) get_shares_info() method_id {
    return unpack_storage();
}